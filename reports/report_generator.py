import json
import pandas as pd
from datetime import datetime
import os
from typing import Dict, List
import logging
from utils.config import Config

logger = logging.getLogger(__name__)

class ReportGenerator:
    def __init__(self):
        self.templates = {
            'market_intelligence': self._get_market_intelligence_template(),
            'd2c_insights': self._get_d2c_insights_template()
        }
    
    def generate_report(self, insights: Dict, report_type: str = "market_intelligence") -> str:
        """Generate comprehensive report"""
        if report_type not in self.templates:
            raise ValueError(f"Unsupported report type: {report_type}")
        
        template = self.templates[report_type]
        report_content = self._prepare_report_content(insights, report_type)
        
        # Generate report
        report = template.format(**report_content)
        
        # Save report
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{report_type}_report_{timestamp}.md"
        filepath = os.path.join(Config.DATA_OUTPUTS_PATH, filename)
        
        os.makedirs(Config.DATA_OUTPUTS_PATH, exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info(f"Report generated: {filepath}")
        return filepath
    
    def generate_d2c_report(self, d2c_insights: Dict) -> str:
        """Generate D2C-specific report"""
        return self.generate_report(d2c_insights, "d2c_insights")
    
    def _get_market_intelligence_template(self) -> str:
        """Get market intelligence report template"""
        return """
# AI-Powered Market Intelligence Report

**Generated on**: {timestamp}  
**Analysis Type**: {analysis_type}  
**Data Sources**: {data_sources}  
**Total Apps Analyzed**: {total_apps:,}

## Executive Summary

{executive_summary}

## Confidence Assessment

{confidence_metrics}

## Market Trends Analysis

### Emerging Categories
{emerging_categories}

### Growth Opportunities
{growth_opportunities}

### Market Maturity & Saturation
{market_maturity}

## Competitive Analysis

### Top Performers Analysis
{top_performers}

### Pricing Strategies
{pricing_strategies}

### Competitive Landscape
{competitive_landscape}

## Strategic Recommendations

### High Priority Actions
{high_priority_actions}

### Investment Priorities
{investment_priorities}

### Risk Factors
{risk_factors}

## Consumer Insights

### User Preference Patterns
{preference_patterns}

### Adoption Drivers
{adoption_factors}

### Retention Strategies
{retention_drivers}

## Statistical Backing

### Data Quality Assessment
{data_quality}

### Category Performance
{category_performance}

### Confidence Scores
{confidence_scores}

---
*Report automatically generated by AI Market Intelligence System*  
*Confidence Score: {overall_confidence}*
"""
    
    def _get_d2c_insights_template(self) -> str:
        """Get D2C insights report template"""
        return """
# D2C eCommerce Intelligence Report

**Generated on**: {timestamp}  
**Analysis Scope**: {analysis_scope}  
**Data Period**: {data_period}

## Executive Summary

{executive_summary}

## Key Performance Metrics

{business_metrics}

## Funnel Analysis

{funnel_analysis}

## Category Performance

{category_performance}

## SEO Opportunities

{seo_opportunities}

## Campaign Insights

{campaign_insights}

## AI-Generated Creative Recommendations

### High-Converting Ad Headline
{ad_headline}

### SEO-Optimized Meta Description
{seo_meta_description}

### Persuasive Product Description
{pdp_text}

## Strategic Recommendations

### Budget Allocation
{budget_recommendations}

### Optimization Priorities
{optimization_priorities}

### KPI Targets
{kpi_targets}

---
*Report automatically generated by AI Market Intelligence System*
"""
    
    def _prepare_report_content(self, insights: Dict, report_type: str) -> Dict:
        """Prepare report content based on insights"""
        if report_type == "market_intelligence":
            return self._prepare_market_intelligence_content(insights)
        else:
            return self._prepare_d2c_content(insights)
    
    def _prepare_market_intelligence_content(self, insights: Dict) -> Dict:
        """Prepare content for market intelligence report"""
        
        # Extract insights
        market_trends = insights.get('insights', {}).get('market_trends', {})
        competitive = insights.get('insights', {}).get('competitive_analysis', {})
        strategic = insights.get('insights', {}).get('strategic_recommendations', {})
        consumer = insights.get('insights', {}).get('consumer_insights', {})
        stats = insights.get('statistical_backing', {})
        confidence = insights.get('confidence_metrics', {})
        priority = insights.get('recommendation_priority', {})
        
        return {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'analysis_type': "Mobile App Market Intelligence",
            'data_sources': "Google Play Store, Apple App Store",
            'total_apps': insights.get('summary', {}).get('total_apps_analyzed', 0),
            'executive_summary': self._generate_executive_summary(insights),
            'confidence_metrics': self._format_confidence_metrics(confidence),
            'emerging_categories': self._format_list(market_trends.get('emerging_categories', [])),
            'growth_opportunities': self._format_list(market_trends.get('growth_opportunities', [])),
            'market_maturity': market_trends.get('market_maturity', 'N/A'),
            'top_performers': competitive.get('top_performers_analysis', 'N/A'),
            'pricing_strategies': self._format_list(competitive.get('pricing_strategies', [])),
            'competitive_landscape': competitive.get('competitive_intensity', 'N/A'),
            'high_priority_actions': self._format_list(priority.get('high_priority', [])),
            'investment_priorities': self._format_list(priority.get('medium_priority', [])),
            'risk_factors': self._format_list(priority.get('considerations', [])),
            'preference_patterns': self._format_list(consumer.get('preference_patterns', [])),
            'adoption_factors': self._format_list(consumer.get('adoption_factors', [])),
            'retention_drivers': self._format_list(consumer.get('retention_drivers', [])),
            'data_quality': self._format_data_quality(stats.get('data_quality', {})),
            'category_performance': self._format_category_performance(stats.get('category_performance', {})),
            'confidence_scores': self._format_confidence_scores(stats.get('category_performance', {})),
            'overall_confidence': f"{confidence.get('overall_confidence', 0):.1%}"
        }
    
    def _prepare_d2c_content(self, insights: Dict) -> Dict:
        """Prepare content for D2C report"""
        
        metrics = insights.get('business_metrics', {})
        funnel = insights.get('funnel_analysis', {})
        category = insights.get('category_performance', {})
        seo = insights.get('seo_opportunities', {})
        campaign = insights.get('campaign_insights', {})
        creatives = insights.get('creative_recommendations', {})
        strategic = insights.get('strategic_recommendations', {})
        
        return {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'analysis_scope': "D2C eCommerce Performance & Funnel Analysis",
            'data_period': "Recent performance data",
            'executive_summary': self._generate_d2c_executive_summary(insights),
            'business_metrics': self._format_d2c_metrics(metrics),
            'funnel_analysis': self._format_funnel_analysis(funnel),
            'category_performance': self._format_d2c_category_performance(category),
            'seo_opportunities': self._format_seo_opportunities(seo),
            'campaign_insights': self._format_campaign_insights(campaign),
            'ad_headline': creatives.get('ad_headline', 'N/A'),
            'seo_meta_description': creatives.get('seo_meta_description', 'N/A'),
            'pdp_text': creatives.get('pdp_text', 'N/A'),
            'budget_recommendations': self._format_budget_recommendations(strategic),
            'optimization_priorities': self._format_optimization_priorities(strategic),
            'kpi_targets': self._format_kpi_targets(strategic)
        }
    
    def _generate_executive_summary(self, insights: Dict) -> str:
        """Generate executive summary for market intelligence"""
        trends = insights.get('insights', {}).get('market_trends', {})
        strategic = insights.get('insights', {}).get('strategic_recommendations', {})
        confidence = insights.get('confidence_metrics', {}).get('overall_confidence', 0)
        
        summary = f"""
This comprehensive market intelligence analysis reveals {len(trends.get('emerging_categories', []))} key emerging categories 
in the mobile app ecosystem with an overall confidence score of {confidence:.1%}.

The analysis identifies significant growth opportunities in {', '.join(trends.get('growth_opportunities', ['multiple sectors'])[:2])} 
while highlighting saturation concerns in established categories. 

Key strategic recommendations include focusing on {', '.join(strategic.get('developer_opportunities', ['strategic development'])[:2])} 
and prioritizing investments in {', '.join(strategic.get('investment_priorities', ['key areas'])[:1])}.

The market shows clear signals for {trends.get('market_maturity', 'continued growth and specialization')}.
"""
        return summary.strip()
    
    def _generate_d2c_executive_summary(self, insights: Dict) -> str:
        """Generate executive summary for D2C report"""
        metrics = insights.get('business_metrics', {})
        strategic = insights.get('strategic_recommendations', {})
        
        summary = f"""
This D2C eCommerce analysis reveals a {metrics.get('average_roas', 0):.2f} ROAS with a customer acquisition cost of ${metrics.get('average_cac', 0):.2f}. 
The funnel analysis shows significant opportunities for optimization, particularly in {insights.get('funnel_analysis', {}).get('funnel_leakage_analysis', {}).get('optimization_priority', ['key areas'])[0]}.

The data supports reallocating budget toward {', '.join(strategic.get('budget_reallocation', {}).get('increase_spend_categories', ['high-performing categories']))} 
while implementing immediate optimizations to improve conversion rates by {strategic.get('kpi_targets', {}).get('conversion_rate_target', 0) * 100:.1f}%.

SEO opportunities represent an estimated ${insights.get('seo_opportunities', {}).get('seo_gap_analysis', {}).get('revenue_opportunity', 0):,.0f} in additional revenue potential.
"""
        return summary.strip()
    
    def _format_confidence_metrics(self, confidence: Dict) -> str:
        """Format confidence metrics for report"""
        return "\n".join([f"- **{key.replace('_', ' ').title()}**: {value:.1%}" for key, value in confidence.items()])
    
    def _format_list(self, items: List) -> str:
        """Format list items for report"""
        return "\n".join([f"- {item}" for item in items])
    
    def _format_data_quality(self, data_quality: Dict) -> str:
        """Format data quality assessment"""
        return f"""
- **Total Records**: {data_quality.get('total_records', 0):,}
- **Data Completeness Score**: {data_quality.get('completeness_score', 0):.1%}
- **Missing Ratings**: {data_quality.get('missing_ratings', 0)}
- **Missing Reviews**: {data_quality.get('missing_reviews', 0)}
"""
    
    def _format_category_performance(self, category_stats: Dict) -> str:
        """Format category performance for report"""
        if not category_stats:
            return "No category performance data available"
        
        top_categories = category_stats.get('top_categories_by_rating', {})
        content = "**Top Categories by Average Rating:**\n"
        for category, score in list(top_categories.items())[:5]:
            content += f"- {category}: {score:.2f}\n"
        
        return content
    
    def _format_confidence_scores(self, category_stats: Dict) -> str:
        """Format confidence scores for report"""
        if not category_stats:
            return "No confidence scores available"
        
        confidence_scores = category_stats.get('confidence_scores', {})
        content = "**Category Confidence Scores:**\n"
        for category, score in sorted(confidence_scores.items(), key=lambda x: x[1], reverse=True)[:5]:
            content += f"- {category}: {score:.1%}\n"
        
        return content
    
    def _format_d2c_metrics(self, metrics: Dict) -> str:
        """Format D2C business metrics"""
        return f"""
- **Average ROAS**: {metrics.get('average_roas', 0):.2f}
- **Average CAC**: ${metrics.get('average_cac', 0):.2f}
- **Average CTR**: {metrics.get('average_ctr', 0):.4f}
- **Total Revenue**: ${metrics.get('total_revenue', 0):,.2f}
- **Total Conversions**: {metrics.get('total_conversions', 0):,}
- **Total Ad Spend**: ${metrics.get('total_ad_spend', 0):,.2f}
"""
    
    def _format_funnel_analysis(self, funnel: Dict) -> str:
        """Format funnel analysis"""
        leakage = funnel.get('funnel_leakage_analysis', {})
        
        content = f"""
**Conversion Rates:**
- Install → Signup: {funnel.get('install_to_signup', 0):.2%}
- Signup → Purchase: {funnel.get('signup_to_purchase', 0):.2%}
- Retention Rate: {funnel.get('retention_rate', 0):.2%}
- Overall Conversion: {funnel.get('overall_conversion_rate', 0):.2%}

**Optimization Priorities:**
"""
        
        for priority in leakage.get('optimization_priority', [])[:3]:
            content += f"- {priority.replace('_', ' ').title()}\n"
        
        return content
    
    def _format_d2c_category_performance(self, category: Dict) -> str:
        """Format D2C category performance"""
        top_roas = category.get('top_categories_by_roas', {})
        top_revenue = category.get('top_categories_by_revenue', {})
        
        content = "**Top Categories by ROAS:**\n"
        for cat, data in list(top_roas.items())[:3]:
            content += f"- {cat}: ROAS {data.get('roas', 0):.2f}, Revenue ${data.get('revenue', 0):,.0f}\n"
        
        content += "\n**Top Categories by Revenue:**\n"
        for cat, data in list(top_revenue.items())[:3]:
            content += f"- {cat}: Revenue ${data.get('revenue', 0):,.0f}, ROAS {data.get('roas', 0):.2f}\n"
        
        return content
    
    def _format_seo_opportunities(self, seo: Dict) -> str:
        """Format SEO opportunities"""
        gap_analysis = seo.get('seo_gap_analysis', {})
        
        return f"""
**Growth Opportunities:**
- Estimated Traffic Gain: {gap_analysis.get('estimated_traffic_gain', 0):,} visits
- Revenue Opportunity: ${gap_analysis.get('revenue_opportunity', 0):,.0f}

**High Opportunity Categories:**
{self._format_seo_categories(seo.get('high_opportunity_categories', {}))}
"""
    
    def _format_seo_categories(self, categories: Dict) -> str:
        """Format SEO categories"""
        if not categories:
            return "No high-opportunity categories identified"
        
        content = ""
        for category, stats in list(categories.items())[:3]:
            content += f"- {category}: Position {stats.get('average_position', 0):.1f}, Volume {stats.get('search_volume', 0):,.0f}\n"
        
        return content
    
    def _format_campaign_insights(self, campaign: Dict) -> str:
        """Format campaign insights"""
        efficiency = campaign.get('performance_gap_analysis', {})
        
        return f"""
**Campaign Performance:**
- High Performers: {campaign.get('high_performer_count', 0)}
- Low Performers: {campaign.get('low_performer_count', 0)}
- ROAS Gap: {efficiency.get('roas_gap', 0):.2f}
- Revenue Gap: ${efficiency.get('revenue_gap', 0):,.0f}
"""
    
    def _format_budget_recommendations(self, strategic: Dict) -> str:
        """Format budget recommendations"""
        budget = strategic.get('budget_reallocation', {})
        
        content = "**Increase Spend In:**\n"
        for category in budget.get('increase_spend_categories', [])[:3]:
            content += f"- {category}\n"
        
        content += "\n**Decrease Spend In:**\n"
        for category in budget.get('decrease_spend_categories', [])[:2]:
            content += f"- {category}\n"
        
        return content
    
    def _format_optimization_priorities(self, strategic: Dict) -> str:
        """Format optimization priorities"""
        priorities = strategic.get('optimization_priorities', {})
        
        content = "**Immediate Actions (1-2 weeks):**\n"
        for action in priorities.get('immediate_actions', [])[:2]:
            content += f"- {action}\n"
        
        content += "\n**Short-term Goals (1-3 months):**\n"
        for goal in priorities.get('short_term_goals', [])[:2]:
            content += f"- {goal}\n"
        
        return content
    
    def _format_kpi_targets(self, strategic: Dict) -> str:
        """Format KPI targets"""
        targets = strategic.get('kpi_targets', {})
        
        return f"""
- **ROAS Target**: {targets.get('next_quarter_roas_target', 0):.2f}
- **CAC Reduction Target**: ${targets.get('cac_reduction_target', 0):.2f}
- **Conversion Rate Target**: {targets.get('conversion_rate_target', 0):.2%}
"""